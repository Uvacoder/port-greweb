---
layout: post
title: Blender as a 2D game level editor - Proof Of Concept
tags:
- 3D
- BBG
- blender
- featured
- game
- game development
- javascript
- Programming
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _flattr_post_language: fr_FR
  _flattr_post_category: text
  _flattr_post_hidden: '0'
  dsq_thread_id: '642562970'
  _flattr_post_customurl: ''
---
A long time ago, video games were only two-dimensional. Of-course this was due to our poor hardware capabilities, but when computers became faster and faster 3D games appeared in mass. 
<strong>Did it kill 2D games? Nope.</strong> They continue to exist because it offer a different gameplay and are easier to make. Maybe also a bit because we are nostalgic of old-school games!

We can distinguish two kinds of 2D games:

<img src="http://blog.greweb.fr/wp-content/uploads/2012/04/bomberman93.jpg" alt="" title="bomberman93" width="200" class="alignleft size-full wp-image-1403" />
<a href="http://www.tonypa.pri.ee/tbw/tut00.html"><strong>Tile based games</strong></a> where the game world is simplified with a big grid - each grid position has some properties.
A map editor is not always needed for tile based games, because the map can be straighforward to represent and maintain like in a <em>Bomberman</em> or in a <em>Pacman</em>. A simple editor is generally used to make graphism with sprites.
<br style="clear: both" />

<img src="http://blog.greweb.fr/wp-content/uploads/2012/04/woarpc001.jpg" alt="" title="woarpc001" width="200" class="alignleft size-full wp-image-1404" />
<strong>Non-tile based games</strong>, which can be called "polygon based games" are more complex.
In such game, like a <em>Worms</em> or a <em>Sonic</em>, it's totally crazy to write the map by hand (objects positions, polygons coordinates, ...). The alternative, is not to use predefined maps, but on-the-fly generated maps which doesn't fit every games.
<br style="clear: both" />

<a href="http://higherorderfun.com/blog/2012/05/20/the-guide-to-implementing-2d-platformers/">Here are more detailed work on these different game designs</a>.

<strong>Making the game engine</strong> is one thing, but <strong>designing the game levels</strong> can be one big work too and <strong>we need tools to make it easier</strong>.

<!--more-->

<h2>Tile based game maps</h2>

In tile based games, maps are usually quite simple to represent.

For instance, here is how we can code the maze of <a href="http://www.masswerk.at/JavaPac/JS-PacMan2.html">Pacman</a>:
[cc_js]
[
"ahhhhhgxbhhdxehhhhhc",
"vp....o......o....pv",
"v.lhm...lhhm...lhm.v",
"v.....n......n.....v",
"v.n.n.v.ahhc.v.n.n.v",
"d.v.o.v.vxxq.v.o.v.b",
"x.v...v.vxxt.v...v.x",
"c.bhm.o.bhhr.o.lhd.a",
"v........x.........v",
"em.lc.am.lm.lc.am.lg",
"v...v.v......v.v...v",
"v.k.o.o.lhhm.o.o.k.v",
"vp................pv",
"bhhhhhcxahhcxahhhhhd"
]
[/cc_js]
where every character is a tile and has a given meaning.

For more complex games, we can also represent the map with a set of objects, and each object has position and size properties (x, y, width, height) and other properties for the game logic.

For instance, see the <em>ImpactJS</em> tile based games editor:

<a href="http://impactjs.com/documentation/weltmeister"><img src="http://blog.greweb.fr/wp-content/uploads/2012/04/weltmeister-tutorial-entities.png" alt="" title="weltmeister-tutorial-entities" width="600" height="355" class="size-full wp-image-1390" /></a>

<h2>But what about polygons based game?</h2>

Well, some have tried to make dedicated 2D game map editor like shown in this video:

<iframe width="420" height="315" src="http://www.youtube.com/embed/kvvEmm2Vyoc" frameborder="0" allowfullscreen></iframe>

but it sounds a bit unfinished and specific.

<h3>Do it yourself, but don't reinvent the wheel.</h3>

<strong>But finally, isn't it what a 3D editor is doing?</strong>

Isn't it the most generic tool we can find?

They have done a lot of awesome work in term of user interface, polygon modeling, textures (procedural / bitmap), ...let's profit of all this work to generate awesome texture map while exporting polygons.

Relying on such tools, you don't have to learn a brand new map editor, you can relax on what you know if you have the chance to know Blender or Maya or anything.

<h3>The Z magic</h3>

Let's ignore the Z dimension, or rather, let's <strong>use the Z-dimension as a way to represent the semantics of the game map!</strong>

This is the map I made for <a href="http://greweb.fr/blazing-race">Blazing Race</a>, a HTML5 against-the-clock platform game where you control a fireball:

<img src="http://blog.greweb.fr/wp-content/uploads/2012/04/zs.png" alt="" title="zs" width="663" height="642" class="size-full wp-image-1417" />

For my game needs, I used <strong>different Z layers to represent different kind of materials and game objects</strong>:

<ul>
<li>z=1 : candles' position - the objective of the game is to light them all</li>
<li>z=0 : the game grounds - where collision occurs</li>
<li>z=-1 : the water areas - where your flame dies</li>
<li>z=-2 : special areas where you miss oxgyen - your flame dies in a few seconds</li>
</ul>

But I also used <strong>objects ids</strong> as an another way to distinguish objects:
a "start" object to define the game start position and two "topleft" and "bottomright" objects to define the game bound.

<h3>Maintain your map source in one file</h3>

Another powerful feature of this, is you can maintain your map polygons AND your map textures in a single way. Use your 3D editor as a polygon editor and use its render engine to generate textures:

<img src="http://blog.greweb.fr/wp-content/uploads/2012/04/map1.png" alt="" title="map" width="494" height="751" class="size-full wp-image-1425" />

Take benefits from what your 3D editor can do.

<h3>Export polygons to the Javascript game</h3>

<img src="http://blog.greweb.fr/wp-content/uploads/2012/04/path4850.png" alt="" title="path4850" width="400" height="59" class="size-full wp-image-1422" />

I've made a transformer which take a COLLADA file in input (the most commonly supported standard format to describe a 3D scene, you can export it from any 3D editor like Blender, Maya, 3DS...) which extract and transform relevant informations from it and give you a json map for your game in output.

<em>It was quite simple to implement, thanks to the Three.js COLLADA importer :)</em>

Here is the current (unfinished) interface for this:

<a href="http://greweb.fr/blazing-race/maps/converter/">
<img src="http://blog.greweb.fr/wp-content/uploads/2012/04/demo_screenshot.png" alt="" title="demo_screenshot" width="639" height="1516" class="alignnone size-full wp-image-1434" />
</a>

As a proof of usability of the output JSON map, the preview was only made in a few lines of Javascript code.

Extract:
[cc_js]
function draw (map) {
  var container = $('#viewport').empty();
  $('#legend').empty();
  a = 0;
  var w = 500;
  var h = Math.floor(w * map.height/map.width);
  var CROSS_SIZE = 3;
  var canvas = $('<canvas width="'+w+'" height="'+h+'"></canvas>');
  var ctx = canvas[0].getContext("2d");
  for (var name in map) {
    var objs = map[name];
    if (objs[0] && objs[0].faces) {
      var color = randomColor(70, 0.8);
      ctx.fillStyle = color;
      for (var i=0; i<objs.length; ++i) {
        var obj = objs[i];
        for (var f=0; f<obj.faces.length; ++f) {
          var face = obj.faces[f];
          ctx.beginPath();
          for (var v=0; v<face.length; ++v) {
            var vertice = obj.vertices[face[v]];
            var x = ctx.canvas.width*vertice.x/map.width;
            var y = ctx.canvas.height*(1-vertice.y/map.height);
            if (v==0)
              ctx.moveTo(x, y);
            else
              ctx.lineTo(x, y);
          }
          ctx.fill();
        }
      }
      addLegend(color, name, true);
    }
  }
  for (var name in map) {
    var objs = map[name];
    if (objs[0] && objs[0].x) {
      var color = randomColor(50);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      for (var i=0; i<objs.length; ++i) {
        var p = objs[i];
        var x = ctx.canvas.width*p.x/map.width;
        var y = ctx.canvas.height*(1-p.y/map.height);
        ctx.beginPath();
        ctx.moveTo(x-CROSS_SIZE, y);
        ctx.lineTo(x+CROSS_SIZE, y);
        ctx.moveTo(x, y-CROSS_SIZE);
        ctx.lineTo(x, y+CROSS_SIZE);
        ctx.stroke();
      }
      addLegend(color, name, false);
    }
  }
  container.append(canvas);
}
[/cc_js]

<h2>What is next?</h2>

Blazing Race, is not finished yet, I need to improve a lot of things ;)

I'll try to release a standalone version of this converter soon with tutorials and examples.
