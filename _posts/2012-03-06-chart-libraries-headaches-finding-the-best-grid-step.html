---
layout: post
title: Chart libraries headaches - finding the best grid step
tags:
- chart
- javascript
- math
- Programming
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _flattr_post_language: sq_AL
  _flattr_post_category: text
  _flattr_post_hidden: '0'
  thumbnail: http://blog.greweb.fr/wp-content/uploads/2012/02/wrong-chart-scale.png
  featured_image: http://blog.greweb.fr/wp-content/uploads/2012/02/wrong-chart-scale.png
  _topsy_long_url: http://blog.greweb.fr/2012/03/chart-libraries-headaches-finding-the-best-grid-step/
  topsy_short_url: ''
  dsq_thread_id: '601208596'
---
<img src="http://blog.greweb.fr/wp-content/uploads/2012/02/wrong-chart-scale.png" alt="" title="wrong-chart-scale" width="250" class="alignleft size-full wp-image-1189" />
If you have ever made a chart library in your life, you've probably asked yourself how to find the best scale for the grid in order to have <strong>nice values to display in the axis</strong>.

Most of the time, <strong>data ranges are unknown</strong>, hence we need to <strong>adapt the grid step</strong> to provide the best display.

<h2>Check this out</h2>

<iframe src="http://greweb.fr/grid-utils/" frameborder="0" width="525" height="140"></iframe>

Let's explain the algorithm...

<!--more-->

<h2>About scientific notation</h2>

Any number can be formatted in scientific notation. It is written in the form of <strong>A x 10<sup>N</sup></strong> and is noted <strong>AeN</strong>.

For instance, 2300 becomes <strong>2.3e3</strong> (because 2300 = 2.3 x 10<sup>3</sup>), 12 becomes <strong>1.2e1</strong>, and 0.23 becomes <strong>2.3e-1</strong>.

Scientific notation is exactly made for <strong>displaying huge or tiny values in a few characters</strong>. 
We can use the same principle for finding good values for the step scale, we can just <strong>keep the pow of 10</strong> part (<strong>N</strong>) and <strong>round the value part</strong> (<strong>A</strong>). 

<h2>Magic numbers</h2>

But <strong>rounding is not enough</strong>, I have found that good pattern numbers of step range is those divisible by 2, 5 and 10.

In math term, we need to find a step range <em>sr</em>, where

[cc]
∀ n ∈ |N, ∀ a ∈ {1, 2, 5}, ∃ sr, sr = a x 10^n
[/cc]

This is basically because 2 x 5 = 10 : using a step of 5 we have a 10 modularity every 2 step, and, using a step of 2 we have a 10 modularity every 5 step.

<strong> 2 step:</strong> 0 2 4 6 8 <strong>10</strong> 12 14 16 18 <strong>20</strong> ...
<strong> 5 step:</strong> 0 5 <strong>10</strong> 15 <strong>20</strong> 25 <strong>30</strong> 35 <strong>40</strong> 45 ...
<strong>10 step:</strong> <strong>0 10 20 30 40 50 60 70 80 90</strong> ...

For any dataset, we need to fallback on the closest step range in all of possible step ranges: ... 0.002, 0.02, 0.2, 2, 20, 200, ..., ... 0.005, 0.05, 0.5, 5, 50, 500, ...,  and ... 0.001, 0.01, 0.1, 1, 10, 100, ..., 

<h3>Calculate the pow of 10</h3>
To get the <strong>N</strong> value of the <strong>A x 10<sup>N</sup></strong> form, we can use the log of 10:
[cc_js]N = Math.log(number) / Math.log(10)[/cc_js]

<h3>Calculate the value modulo 10</h3>
To get the <strong>A</strong> value of the <strong>A x 10<sup>N</sup></strong> form, we can just divide the number by <strong>10<sup>N</sup></strong>:
[cc_js]A = number / Math.pow(10, N)[/cc_js]

<h3>'Rounding' the number</h3>
We know just need to change the value of <strong>A</strong> and make it more "readable".
We can map the value as follow:

[cc]
if A ∈ [0, 1.5[ then A becomes 1
if A ∈ [1.5, 3.5[ then A becomes 2
if A ∈ [3.5, 7.5[ then A becomes 5
if A ∈ [7.5, 10[ then A becomes 10
[/cc]

Note that these rules may probably be improved, I would love if someone could improve this (because I use a arithmetic mean approach and it should probably be arithmetic).

<h2>Implementation</h2>

<h3>Scala</h3>

<script src="https://gist.github.com/1987311.js?file=GridUtils.scala"></script>

<h3>Javascript</h3>

<script src="https://gist.github.com/1987311.js?file=GridUtils.js"></script>

<strong>Usage example:</strong>
[cc_js]
GridUtils.findNiceRoundStep (xMax, 10)
[/cc_js]
where <em>xMax</em> is the scale of the axis, and <em>10</em> is the desired number of graduation split.

<h2>Conclusion</h2>

Finding the best grid step is finally a simple thing to implement but is an essential feature every chart libraries should have.
