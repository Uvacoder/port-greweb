---
layout: post
title: Zound, a PlayFramework 2 audio streaming experiment using Iteratees
tags:
- audio
- featured
- Iteratee
- play2
- playframework
- Web
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _flattr_post_hidden: '0'
  _flattr_post_customurl: ''
  dsq_thread_id: '784598067'
  _wp_old_slug: zound-a-playframework-audio-streaming-experiment-using-iteratees
---
<img src="http://blog.greweb.fr/wp-content/uploads/2012/07/ZOUND.png" alt="" title="ZOUND" width="605" height="263" class="alignnone size-full wp-image-1962" />

Last Friday was HackDay #7 at <a href="http://zenexity.com" target="_blank">Zenexity</a>, and we decided to work on a real-time audio <a href="http://github.com/gre/zound" target="_blank">experiment</a> made with <a href="http://playframework.org" target="_blank">Play Framework</a>. The plan was to use an audio generator (<a href="http://www.softsynth.com/jsyn/" target="_blank">JSyn</a>, an audio synthesizer), encode the output and stream it all using Play Iteratees to pipe everything in real-time.

<iframe width="480" height="360" src="http://www.youtube.com/embed/taDLKTcNHnQ" frameborder="0" allowfullscreen></iframe>

<strong>First of all, let's highlight some interesting part of the project, then get into some of the details.</strong>

Thanks to <a href="https://twitter.com/Sadache" target="_blank">@Sadache</a> for his Iteratee expertise, we ended up with a simple line of code that does all of the hard work:

[cc_scala]val chunkedAudioStream = rawStream &> chunker &> audioEncoder[/cc_scala]

You can think of the <strong>[cci]&>[/cci]</strong> operator as the UNIX pipe <strong>[cci]|[/cci]</strong>. So we simply take the [cci_scala]rawStream[/cci_scala], chunk it with a [cci_scala]chunker[/cci_scala] and encode it with an [cci_scala]audioEncoder[/cci_scala].

Now, <strong>rawStream</strong> is the raw stream of audio samples (numbers between -1 and 1) generated by the audio synthesizer. Next, the <strong>chunker</strong> buffers a data stream into chunk of bytes. For instance, if you send data stream at 1Kb/s to a 10Kb chunker, it will output one chunk of size 10Kb every 10 seconds. And finally, the <strong>audioEncoder</strong> takes <strong>audio samples</strong> and outputs encoded bytes implementing an audio format (like WAVE).

We can then make a broadcast of the stream:

[cc_scala]val (sharedChunkedAudioStream, _) = 
  Concurrent.broadcast(chunkedAudioStream)[/cc_scala]

And then the <strong>sharedChunkedAudioStream</strong> is now a shared stream for every consumer (clients). All that's left to do is to stream it over HTTP:

[cc_scala]
def stream = Action {
  Ok.stream(audioHeader >>> sharedChunkedAudioStream).
     withHeaders( ("Content-Type", audio.contentType) )
}
[/cc_scala]

The [cci]>>>[/cci] operator means "concatenation", so here we're concatenating the <strong>audio header</strong> (given by the format like WAVE) with the current <strong>chunked audio stream</strong>. We also send the right HTTP <strong>Content-Type</strong> header (like "audio/wav" for WAVE).

Another interesting part of the project is the <strong>multi-user web user interface: allowing users to interact with the sound synthesis</strong>.

Using <a href="https://twitter.com/mrspeaker" target="_blank">@mrspeaker</a>'s audio synthesis expertise, we started creating a synthesizer generator - 3 oscillators, various wave shapes, frequency and volumes, and finally flowing through a high pass filter before entering our "rawStream" above.

Thanks to the Play framework goodness, <strong>this audio stream can be both consumed by the web page with an HTML audio tag, and with a stream player such as VLC!</strong> Ok, that's the project - let's have a closer look at some of the concepts...

<!--more-->

<h2>What is sound?</h2>

<blockquote>Sound is a mechanical wave that is an oscillation of pressure transmitted through a solid, liquid, or gas, composed of frequencies within the range of hearing and of a level sufficiently strong to be heard, or the sensation stimulated in organs of hearing by such vibrations. <strong><em>Wikipedia</em></strong></blockquote>

We can represents the sound like any wave as a graphic of the amplitude (the oscillation pressure) as a function of time. Here you see it in Audacity:

<img src="http://blog.greweb.fr/wp-content/uploads/2012/07/sound-audacity.png" alt="" title="sound-audacity" class="alignnone size-full wp-image-1901" />

Electricity is used to pump these amplitudes to your speakers, over time.

<h3>About primitive wave sounds</h3>

There are some patterns - some primitives waves - we can easily generate with computers (or before with analog oscillators). Those are well known by mathematicians and physicians: Sine wave, Triangle wave, Square wave,...

<a href="http://en.wikipedia.org/wiki/File:Waveforms.svg" target="_blank"><img src="http://blog.greweb.fr/wp-content/uploads/2012/07/557px-Waveforms.svg_.png" alt="" title="557px-Waveforms.svg" width="557" height="480" class="alignnone size-full wp-image-1904" /></a>

A sine wave produce a smooth tone, whereas Triangle and Square wave are more aggressive sounds. The shorter a wave period is, the lower the note you hear: it's called the frequency.

<h3>How is sound represented by computer?</h3>

Whereas analog oscillators generate sounds in an <em>almost*</em> continuous stream of electricity, computers are not able to generate continuous stream of data. This is why with computers the sound is divided in to discrete <strong>samples</strong>, usually <strong>44100 samples per second</strong> for standard CD quality audio. Each sample is a value (amplitude) for a given time position.

<a href="http://en.wikipedia.org/wiki/Sampling_(signal_processing)" target="_blank">See Sampling (wikipedia)</a>.

If you zoom in Audacity, you can actually see each sample:
<img src="http://blog.greweb.fr/wp-content/uploads/2012/07/audacity-zoom-ah.png" alt="" title="audacity-zoom-ah" width="500" height="228" class="alignnone size-full wp-image-1907" />
This is an "AH" timbre of my voice. A timbre is unique to everyone, it's the pattern the sound wave take when you speak. <strong>The amplitude of an audio sample is usually represented as a Real number between -1.0 and 1.0</strong>.

<em>* electricity is not strictly continuous, we have electrons out there!</em>

Ok, Let's go back to our experiment now!

<h2>The experiment</h2>

Our experiment is using <a href="http://www.playframework.org/" target="_blank">Play Framework</a> and is written in <a href="scala-lang.org/" target="_blank">Scala language</a>. Specifically, our project takes advantage of Play framework's powerful <strong>Iteratee</strong>s.

<blockquote>Take the expressivity of UNIX pipes, bring the power of Scala, mix it with Play Framework and you got a powerful framework for handling real-time and web streaming.</blockquote>

The iteratee (and related constructs) can take a bit of getting used to. I recommend checking out <a href="http://sadache.tumblr.com/post/26784721867/is-socket-push-bytes-all-what-you-need-to-program" target="_blank">this article on Iteratees in Play</a> and/or <a href="http://www.infoq.com/presentations/Play-I-ll-See-Your-Async-and-Raise-You-Reactive" target="_blank">this presentation</a> if you are interested in learning more about Play2 and reactive programming with Iteratees. And if you just want to see how it work - you can read the source code at <a href="https://github.com/playframework/Play20/tree/master/framework/src/play/src/main/scala/play/api/libs/iteratee" target="_blank">Play20 Github source code</a>.

<h3>Generating the audio stream</h3>

[cc_scala]
val (rawStream, channel) = Concurrent.broadcast[Array[Double]]
val zound = new ZoundGenerator(channel).start()
[/cc_scala]

We create an [cci_scala]Array[Double][/cci_scala] broadcast which return two values: the <strong>rawStream</strong> will be used to read the generated data, and the <strong>channel</strong> used by the generator to push generated audio samples. We give this channel to the <strong>ZoundGenerator</strong>. The [cci_scala].start()[/cci_scala] then starts the audio generation. All of the generation is done using the JSyn library.

Here's a snippet from the <strong>ZoundGenerator</strong> class showing the connection between <strong>JSyn</strong> and <strong>Channel</strong>:

[cc_scala]
class ZoundGenerator(output: Channel[Array[Double]]) {
  val out = new MonoStreamWriter()

  val synth = {
    val synth = JSyn.createSynthesizer()
    synth.add(out)
    out.setOutputStream(new AudioOutputStream(){
      def close() {}
      def write(value: Double) {
        output.push(Array(value))
      }
      def write(buffer: Array[Double]) {
        write(buffer, 0, buffer.length)
      }
      def write(buffer: Array[Double], start: Int, count: Int) {
        output.push(buffer.slice(start, start+count))
      }
    })
    synth
  }
  // ...
[/cc_scala]

We have to implement the methods of AudioOutputStream - but it's just a matter of pushing each audio sample to the channel. It's that simple!

<h3>Encoding the raw audio stream</h3>

For now, we have only implemented the <a href="http://en.wikipedia.org/wiki/WAV" target="_blank">WAVE format</a>. Basically, WAVE has 2 parts; the WAVE header which describes important information (like the framerate and the bits per sample), and the data.
The data is encoded in a simple manner I won't describe here but you can look to the encoder I made here: <a href="https://gist.github.com/3192673" target="_blank">https://gist.github.com/3192673</a>

Now more interesting, let's wrap it with Play Iteratees:

[cc_scala]
val audio = MonoWaveEncoder() // instanciate the WAV encoder
val audioHeader = Enumerator(audio.header)
val audioEncoder = Enumeratee.map[Array[Double]](audio.encodeData)
[/cc_scala]

<em><strong>N. B.</strong>: Remember that Scala is a typed language but where the type declaration is optional because the compiler can infer the type.</em>

<strong>audioHeader</strong> is an [cci_scala]Enumerator[/cci_scala] which means it can <em>produce</em> data, and here the data is the audio header. More precisely it's an [cci_scala]Enumerator[Array[Byte]][/cci_scala] because audio.header is an [cci_scala]Array[Byte][/cci_scala]. Note that contained data is not "consumed" like it would be for an [cci_scala]InputStream[/cci_scala]. Each time you use this enumerator, it gives you its entire content.

<strong>audioEncoder</strong> is an [cci_scala]Enumeratee[Array[Double], Array[Byte]][/cci_scala]. It takes an [cci_scala]Array[Double][/cci_scala] from input and returns an [cci_scala]Array[Byte][/cci_scala] as output. The input is a raw array of audio samples (double numbers between -1.0 and 1.0). The output is the encoded array of bytes.

More formally, an [cci_scala]Enumeratee[A, B][/cci_scala] is an <em>adapter</em> which maps some data of type A to new data of type B. You can implement the way the data is transformed with the map function. Here we just give it the [cci_scala]audio.encodeData[/cci_scala] function.

<h3>Streaming it</h3>

We can basically stream the audio stream with Play2 like so:

[cc_scala]
def stream = Action {
  val audioStream = rawStream &> audioEncoder
  Ok.stream(audioHeader >>> audioStream).
     withHeaders( (CONTENT_TYPE, audio.contentType) )
} 
[/cc_scala]

The [cci_scala]rawStream &> audioEncoder[/cci_scala] takes the raw stream and <strong>pipes</strong> it into the encoder which results in the encoded audio stream. [cci_scala]audioHeader >>> audioStream[/cci_scala] will <strong>concatenate</strong> [cci_scala]audioHeader[/cci_scala] with [cci_scala]audioStream[/cci_scala]. Hence, the first thing the server will do is start sending the audio header to the client <strong>and then</strong> stream the audio in real-time.

<strong>A client can connect at any time and will hear current stream</strong>, so it should simultaneously hear the same thing as any other client (with some delay depending on the client buffer). If the generator stops emitting audio samples, the http client will stop receiving audio data - but it will still be waiting for the server, so the audio play will pause until the server re-sends new audio samples. <strong>That is pretty cool!</strong> - because of the way iteratees work, the stream doesn't just die when all of the input is consumed.

<h4>A chunker to reduce HTTP packet numbers</h4>

Up to now we've been streaming the audio in <strong>very small chunks</strong> because by default JSyn writes out arrays of just 8 audio samples and the [cci_scala].stream()[/cci_scala] function consumes all data as it comes. This means <em>a lot</em> of HTTP chunks per second are sent -  which is less efficient and take more bandwidth.

In order to fix this, we need to use a <strong>buffer on the server side</strong>. In other words, instead of sending audio samples as they come we need to <strong>group audio samples</strong>. We have currently grouped audio samples in arrays of 5000 which is quite reasonable (it's about 10 chunks per second using 44100 samples/s). We can easily change this later. This logic is implemented in an [cci_scala]Enumeratee[/cci_scala] we called "chunker". In that sense, it is reusable and modular:

[cc_scala]val chunker = Enumeratee.grouped(
  Traversable.take[Array[Double]](5000) &>> Iteratee.consume()
)[/cc_scala]

And now, we can easily plug it in like this:

[cc_scala]def stream = Action {
  val chunkedAudioStream = rawStream &> chunker &> audioEncoder
  Ok.stream(audioHeader >>> chunkedAudioStream).
     withHeaders( (CONTENT_TYPE, audio.contentType) )
}[/cc_scala]

<h3>Broadcast</h3>

Now, another improvement we made was to <strong>factorize this chunking and encoding part: avoiding having this computing tasks done for every stream consumer</strong>.

Basically, we move it out of the stream function:

[cc_scala]val chunkedAudioStream = rawStream &> chunker &> audioEncoder
def stream = Action {
  Ok.stream(audioHeader >>> chunkedAudioStream).
     withHeaders( (CONTENT_TYPE, audio.contentType) )
}[/cc_scala]

But to allow broadcasting, we have to use a broadcast:

[cc_scala]
val chunkedAudioStream = rawStream &> chunker &> audioEncoder
val (sharedChunkedAudioStream, _) =  = 
  Concurrent.broadcast(chunkedAudioStream)
def stream = Action {
  Ok.stream(audioHeader >>> sharedChunkedAudioStream).
     withHeaders( (CONTENT_TYPE, audio.contentType) )
}
[/cc_scala]

Here we only care about the enumerator (the left argument in the Tuple2), we put the wildcard "_" to ignore the return value.

<a href="http://en.wikipedia.org/wiki/Broadcasting_(networking)" target="_blank"><img src="http://blog.greweb.fr/wp-content/uploads/2012/07/320px-Broadcast.svg_.png" alt="" title="320px-Broadcast.svg" width="320" height="213" class="alignnone size-full wp-image-1921" /></a>

Using a broadcast, generated audio samples pushed by the audio generator can be simultaneously spread to multiple consumers. This is perfect for our needs, multiple players can connect to this web radio!

<h3>Avoiding the server load</h3>

The last important fix we made was to <strong>avoid the server load</strong>:
[cc_scala]
  def stream = Action {
    Ok.stream(audioHeader >>> sharedChunkedAudioStream 
      &> Concurrent.dropInputIfNotReady(50)).
       withHeaders( (CONTENT_TYPE, audio.contentType) )
  }
[/cc_scala]

If a client is opening the stream connection but doesn't consume enough or doesn't consume it at all (download is paused), the server will fill in memory the chunks to send to the client and the server can reach an <em>out of memory</em> exception. To avoid that <strong>we have to drops chunks if the consumer is not ready</strong>. Then the client will just lose messages if it is not ready (in our case, we give them 50 milliseconds).

And this is what [cci_scala]Concurrent.dropInputIfNotReady(50)[/cci_scala] is actually doing - with yet another <strong>Enumeratee</strong>! <strong>Dropping old chunks is really what we want in an audio streaming application</strong>: We want the consumer to subscribe to the current audio stream and not to continue from where they stopped.

<h3>Client consumers</h3>

<h4>HTML5 Audio tag</h4>

In HTML5, we have the Audio tag - and we can just consume our stream like this:
[cc_html]<audio src="/stream.wav"></audio>[/cc_html]

Or if we want to make it auto loading:
[cc_html]<audio src="/stream.wav" preload autoplay controls></audio>[/cc_html]

It may be a bit "wrong" to use [cci_html]<audio>[/cci_html] for streaming, but it works because we are using it as if the server was hosting a static audio file. The only disputable hack is to have to set the max ChunkSize in the WAVE header which is 2147483647 (it's about 6 hours 45mn!), so the browser believes the audio is not finished.

The issue we are currently facing is this crazy latency (a few seconds) between user actions and the produced sound. This problem is due to the browser audio cache buffer: if we were able to minimize it we would have an almost real-time audio player.

<h4>Playing it with VLC</h4>

This stream is spread through HTTP so we need a HTTP client to consume it. But a HTTP client doesn't mean only browsers! We can also use VLC for this, as if it was a web radio! One advantage of using VLC is it suffers far less latency (presumably because the cache buffer is smaller than the audio tag).

<img src="http://blog.greweb.fr/wp-content/uploads/2012/07/vlc.png" alt="" title="vlc" width="592" height="457" class="alignnone size-full wp-image-1925" />

<h2>Making the real-time control UI</h2>

Our experiment <strong>mixes different oscillators to generator one sound</strong>. The web user interface allows a user to control the parameters of those. Two knobs control the <strong>volume</strong> and the <strong>pitch</strong> (tuned to a dorian mode scale) and you can select the oscillator <strong>wave primitive</strong> (sine, sawtooth, square, noise). It's not fancy at the moment - but JSYN offers a lot of features for expanding our simple demo.

<img src="http://blog.greweb.fr/wp-content/uploads/2012/07/Capture-d’écran-2012-07-31-à-16.42.15.png" alt="" title="Capture d’écran 2012-07-31 à 16.42.15" width="189" height="157" class="alignnone size-full wp-image-1953" />

This interface is <strong>multi-users</strong>, so if you use it with other people, <strong>the interface will stay synchronized over multiple browsers</strong> (turn the knobs, change the wave primitive, ...). All this is done with WebSockets, and on the server-side it's using, again, <strong>Iteratees</strong>!

The workflow is simple: When someone does some action on the user interface, events are sent to the server. These events are interpreted by the <em>ZoundGenerator</em> resulting in updates to the audio synthesis configuration. These events are then broadcast to each client, and some Javascript handlers are called in order to keep the interface synchronized.

<h2>Source code</h2>

<strong><a href="http://github.com/gre/zound" target="_blank">Fork me on Github</a></strong>

<h2>What's next?</h2>

This was just a simple demo to show the power and flexibility of Play2's Iteratee concept. Because of the modular nature, extending the demo is easy. For example, we could plug a new audio encoder such an OGG encoder. The code would be simple and we could even choose on a request-by-request basis which encoder to use:

[cc_scala]
import Concurrent.broadcast
val (chunkedWaveStream, _) = 
  broadcast(rawStream &> chunker &> waveEncoder)
val (chunkedOggStream, _) = 
  broadcast(rawStream &> chunker &> oggEncoder)

def stream(format: String) = Action {
  val stream = format match {
    case "wav" => waveHeader >>> chunkedWaveStream
    case "ogg" => oggHeader >>> chunkedOffStream
  }
  Ok.stream(stream).
     withHeaders( (CONTENT_TYPE, audio.contentType) )
}
[/cc_scala]

<strong>Now it's up to you!</strong>

Hopefully you get a feel for the possibilities of stream processing and piping with Play. You can now reuse these concepts and make your own stuff: Maybe you don't need to generate sounds on the fly, but instead you simply want to play a collection of audio files and stream them like radio? <strong>Well you can make a web radio engine now!</strong>. 

But that's just the beginning - I would love to see someone taking the concept, and running even further... Do you know that in Youtube, during the time you are uploading a video, Youtube is already re-encoding it and can start streaming it <em>before</em> the file has finished uploading? Hmm, that's starting to sound almost simple...
