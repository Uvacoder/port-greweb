---
layout: post
title: Bezier Curve based easing functions - from concept to implementation
tags:
- animation
- bezier
- css
- javascript
- Programming
- Web
status: publish
type: post
published: true
meta:
  _flattr_post_language: sq_AL
  _flattr_post_category: text
  _flattr_post_hidden: '0'
  _flattr_btn_disabled: ''
  _edit_last: '1'
  _topsy_long_url: http://blog.greweb.fr/2012/02/bezier-curve-based-easing-functions-from-concept-to-implementation/
  topsy_short_url: ''
  dsq_thread_id: '593414437'
---
<img src="http://blog.greweb.fr/wp-content/uploads/2012/02/Capture-d’écran-2012-02-29-à-11.26.01.png" alt="" title="Bezier example" width="239" height="235" class="alignleft size-full wp-image-1159" />

Many animation libraries are today using <strong>easing functions</strong> - functions of time returning a progression percentage value. This is required to perform such cool effects:

<iframe src="http://greweb.fr/ease-animation/" frameborder="0" height="40" width="300"></iframe> 

<br style="clear: left" />

But most of these libraries implement a huge collection of functions. We will see how we can generalize them with bezier curves.

<!--more-->

For instance, we use to do this:

[cc_javascript]
EasingFunctions = {
  linear: function (t) { return t },
  easeInQuad: function (t) { return t*t },
  easeOutQuad: function (t) { return t*(2-t) },
  easeInOutQuad: function (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t },
  easeInCubic: function (t) { return t*t*t },
  easeOutCubic: function (t) { return (--t)*t*t+1 },
  easeInOutCubic: function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 },
  easeInQuart: function (t) { return t*t*t*t },
  easeOutQuart: function (t) { return 1-(--t)*t*t*t },
  easeInOutQuart: function (t) { return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t },
  easeInQuint: function (t) { return t*t*t*t*t },
  easeOutQuint: function (t) { return 1+(--t)*t*t*t*t },
  easeInOutQuint: function (t) { return t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }
}
[/cc_javascript]

Defining such functions is lot of math fun but it is very <strong>specific</strong> and not really customizable. Hopefully, we can generalize these easing functions. With <strong>Bezier curves</strong>.

In fact, this work has already been done in CSS Transitions and CSS Animations specifications! You can use [cci lang="css"]transition-timing-function[/cci] CSS property and give a [cci lang="css"]cubic-bezier(x1, y1, x2, y2)[/cci] value (all <strong>ease, linear, ease-in, ease-out, ease-in-out</strong> values are just fallbacking on this cubic-bezier usage).

<img src="http://blog.greweb.fr/wp-content/uploads/2012/02/TimingFunction.png" alt="" width="300" class="alignleft size-full wp-image-1093" />

In a bezier curve based easing function, the X axis is the <strong>time axis</strong> whereas the Y axis represents the <strong>percentage of progress</strong> of the animation.
The two points P1 and P2 are called <strong>handles</strong> and you can (exclusively) control their X and Y positions to generate every possible cubic timing function.

<br style="clear: left" />

<h3>Live demo</h3>
Try to interact with the handles:
<iframe src="http://greweb.fr/bezier-easing/" frameborder="0" width="560" height="400"></iframe>

<h2>Implementation</h2>

Ok, so, this bezier curve concept is great but how can I implement it?

I've read <a href="http://13thparallel.com/archive/bezier-curves/">here</a>  how simple is it to <strong>compute many points of a Bezier curve</strong> and potentially draw them:

[cc_javascript]
function B1(t) { return t*t*t }
function B2(t) { return 3*t*t*(1-t) }
function B3(t) { return 3*t*(1-t)*(1-t) }
function B4(t) { return (1-t)*(1-t)*(1-t) }
function getBezier(percent,C1,C2,C3,C4) {
  var pos = new coord();
  pos.x = C1.x*B1(percent) + C2.x*B2(percent) + C3.x*B3(percent) + C4.x*B4(percent);
  pos.y = C1.y*B1(percent) + C2.y*B2(percent) + C3.y*B3(percent) + C4.y*B4(percent);
  return pos;
}
[/cc_javascript]
But it's not enough. We need to project a point to the Bezier curve, in other words, we need to get the Y of a given X in the bezier curve, and we can't just get it with the [cci_javascript]percent[/cci_javascript] parameter of the Bezier computation.
<strong>We need an interpolation.</strong>

<h3>Deep into Firefox implementation</h3>
In Mozilla Firefox, The bezier curve interpolation is implemented in nsSMILKeySpline.cpp : <a href="https://gist.github.com/1925793">https://gist.github.com/1925793</a>.

What we can learn from it is:
<ul>
	<li>A first optimization store <strong>sample values of the bezier curve</strong> in a small table used to roughly find a initial X guess.</li>
	<li>Then, it use two different implementation strategies: One use the <a href="http://en.wikipedia.org/wiki/Newton%27s_method">Newton's method</a> and the other is just a <a href="http://en.wikipedia.org/wiki/Dichotomic_search">dichotomic search</a> (binary subdivision).</li>
	<li>A <strong>criteria</strong> based on the <strong>slope</strong> give the best strategy to take.</li>
</ul>

These sub-optimizations probably make the difference for the C++ version but are not really relevant for the JavaScript implementation. Moreover, I have only used the Newton's method algorithm.
And this is the code:

<script src="https://gist.github.com/1926947.js?file=KeySpline.js"></script>

Now we can just alias some classic easing function - like CSS does.

<script src="https://gist.github.com/1926947.js?file=EasingFunctions.json"></script>

I'm working on the next version of <a href="http://sliderjs.org/">Slider.JS</a> which relies on 3 different technologies for image transitions: <strong>CSS Transitions</strong>, <strong>Canvas</strong> and <strong>GLSL shaders (from WebGL)</strong>. 
I have now found <strong>a common way to describe easing functions for both CSS-based and Javascript-based animations</strong>!

This example has shown that sometimes, finding a larger solution for a problem is more interesting than having specific solutions.
<strong>This is called the <a href="http://en.wikipedia.org/wiki/Inventor's_paradox">Inventor's paradox</a>.</strong>
